"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@otplib+core@12.0.1";
exports.ids = ["vendor-chunks/@otplib+core@12.0.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@otplib+core@12.0.1/node_modules/@otplib/core/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@otplib+core@12.0.1/node_modules/@otplib/core/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @otplib/core\n *\n * @author Gerald Yeo <contact@fusedthought.com>\n * @version: 12.0.1\n * @license: MIT\n **/\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction objectValues(value) {\n  return Object.keys(value).map(key => value[key]);\n}\n(function (HashAlgorithms) {\n  HashAlgorithms[\"SHA1\"] = \"sha1\";\n  HashAlgorithms[\"SHA256\"] = \"sha256\";\n  HashAlgorithms[\"SHA512\"] = \"sha512\";\n})(exports.HashAlgorithms || (exports.HashAlgorithms = {}));\nconst HASH_ALGORITHMS = objectValues(exports.HashAlgorithms);\n(function (KeyEncodings) {\n  KeyEncodings[\"ASCII\"] = \"ascii\";\n  KeyEncodings[\"BASE64\"] = \"base64\";\n  KeyEncodings[\"HEX\"] = \"hex\";\n  KeyEncodings[\"LATIN1\"] = \"latin1\";\n  KeyEncodings[\"UTF8\"] = \"utf8\";\n})(exports.KeyEncodings || (exports.KeyEncodings = {}));\nconst KEY_ENCODINGS = objectValues(exports.KeyEncodings);\n(function (Strategy) {\n  Strategy[\"HOTP\"] = \"hotp\";\n  Strategy[\"TOTP\"] = \"totp\";\n})(exports.Strategy || (exports.Strategy = {}));\nconst STRATEGY = objectValues(exports.Strategy);\nconst createDigestPlaceholder = () => {\n  throw new Error('Please provide an options.createDigest implementation.');\n};\nfunction isTokenValid(value) {\n  return /^(\\d+)$/.test(value);\n}\nfunction padStart(value, maxLength, fillString) {\n  if (value.length >= maxLength) {\n    return value;\n  }\n  const padding = Array(maxLength + 1).join(fillString);\n  return `${padding}${value}`.slice(-1 * maxLength);\n}\nfunction keyuri(options) {\n  const tmpl = `otpauth://${options.type}/{labelPrefix}:{accountName}?secret={secret}{query}`;\n  const params = [];\n  if (STRATEGY.indexOf(options.type) < 0) {\n    throw new Error(`Expecting options.type to be one of ${STRATEGY.join(', ')}. Received ${options.type}.`);\n  }\n  if (options.type === 'hotp') {\n    if (options.counter == null || typeof options.counter !== 'number') {\n      throw new Error('Expecting options.counter to be a number when options.type is \"hotp\".');\n    }\n    params.push(`&counter=${options.counter}`);\n  }\n  if (options.type === 'totp' && options.step) {\n    params.push(`&period=${options.step}`);\n  }\n  if (options.digits) {\n    params.push(`&digits=${options.digits}`);\n  }\n  if (options.algorithm) {\n    params.push(`&algorithm=${options.algorithm.toUpperCase()}`);\n  }\n  if (options.issuer) {\n    params.push(`&issuer=${encodeURIComponent(options.issuer)}`);\n  }\n  return tmpl.replace('{labelPrefix}', encodeURIComponent(options.issuer || options.accountName)).replace('{accountName}', encodeURIComponent(options.accountName)).replace('{secret}', options.secret).replace('{query}', params.join(''));\n}\nclass OTP {\n  constructor(defaultOptions = {}) {\n    this._defaultOptions = Object.freeze({ ...defaultOptions\n    });\n    this._options = Object.freeze({});\n  }\n  create(defaultOptions = {}) {\n    return new OTP(defaultOptions);\n  }\n  clone(defaultOptions = {}) {\n    const instance = this.create({ ...this._defaultOptions,\n      ...defaultOptions\n    });\n    instance.options = this._options;\n    return instance;\n  }\n  get options() {\n    return Object.freeze({ ...this._defaultOptions,\n      ...this._options\n    });\n  }\n  set options(options) {\n    this._options = Object.freeze({ ...this._options,\n      ...options\n    });\n  }\n  allOptions() {\n    return this.options;\n  }\n  resetOptions() {\n    this._options = Object.freeze({});\n  }\n}\n\nfunction hotpOptionsValidator(options) {\n  if (typeof options.createDigest !== 'function') {\n    throw new Error('Expecting options.createDigest to be a function.');\n  }\n  if (typeof options.createHmacKey !== 'function') {\n    throw new Error('Expecting options.createHmacKey to be a function.');\n  }\n  if (typeof options.digits !== 'number') {\n    throw new Error('Expecting options.digits to be a number.');\n  }\n  if (!options.algorithm || HASH_ALGORITHMS.indexOf(options.algorithm) < 0) {\n    throw new Error(`Expecting options.algorithm to be one of ${HASH_ALGORITHMS.join(', ')}. Received ${options.algorithm}.`);\n  }\n  if (!options.encoding || KEY_ENCODINGS.indexOf(options.encoding) < 0) {\n    throw new Error(`Expecting options.encoding to be one of ${KEY_ENCODINGS.join(', ')}. Received ${options.encoding}.`);\n  }\n}\nconst hotpCreateHmacKey = (algorithm, secret, encoding) => {\n  return Buffer.from(secret, encoding).toString('hex');\n};\nfunction hotpDefaultOptions() {\n  const options = {\n    algorithm: exports.HashAlgorithms.SHA1,\n    createHmacKey: hotpCreateHmacKey,\n    createDigest: createDigestPlaceholder,\n    digits: 6,\n    encoding: exports.KeyEncodings.ASCII\n  };\n  return options;\n}\nfunction hotpOptions(opt) {\n  const options = { ...hotpDefaultOptions(),\n    ...opt\n  };\n  hotpOptionsValidator(options);\n  return Object.freeze(options);\n}\nfunction hotpCounter(counter) {\n  const hexCounter = counter.toString(16);\n  return padStart(hexCounter, 16, '0');\n}\nfunction hotpDigestToToken(hexDigest, digits) {\n  const digest = Buffer.from(hexDigest, 'hex');\n  const offset = digest[digest.length - 1] & 0xf;\n  const binary = (digest[offset] & 0x7f) << 24 | (digest[offset + 1] & 0xff) << 16 | (digest[offset + 2] & 0xff) << 8 | digest[offset + 3] & 0xff;\n  const token = binary % Math.pow(10, digits);\n  return padStart(String(token), digits, '0');\n}\nfunction hotpDigest(secret, counter, options) {\n  const hexCounter = hotpCounter(counter);\n  const hmacKey = options.createHmacKey(options.algorithm, secret, options.encoding);\n  return options.createDigest(options.algorithm, hmacKey, hexCounter);\n}\nfunction hotpToken(secret, counter, options) {\n  const hexDigest = options.digest || hotpDigest(secret, counter, options);\n  return hotpDigestToToken(hexDigest, options.digits);\n}\nfunction hotpCheck(token, secret, counter, options) {\n  if (!isTokenValid(token)) {\n    return false;\n  }\n  const systemToken = hotpToken(secret, counter, options);\n  return token === systemToken;\n}\nfunction hotpKeyuri(accountName, issuer, secret, counter, options) {\n  return keyuri({\n    algorithm: options.algorithm,\n    digits: options.digits,\n    type: exports.Strategy.HOTP,\n    accountName,\n    counter,\n    issuer,\n    secret\n  });\n}\nclass HOTP extends OTP {\n  create(defaultOptions = {}) {\n    return new HOTP(defaultOptions);\n  }\n  allOptions() {\n    return hotpOptions(this.options);\n  }\n  generate(secret, counter) {\n    return hotpToken(secret, counter, this.allOptions());\n  }\n  check(token, secret, counter) {\n    return hotpCheck(token, secret, counter, this.allOptions());\n  }\n  verify(opts) {\n    if (typeof opts !== 'object') {\n      throw new Error('Expecting argument 0 of verify to be an object');\n    }\n    return this.check(opts.token, opts.secret, opts.counter);\n  }\n  keyuri(accountName, issuer, secret, counter) {\n    return hotpKeyuri(accountName, issuer, secret, counter, this.allOptions());\n  }\n}\n\nfunction parseWindowBounds(win) {\n  if (typeof win === 'number') {\n    return [Math.abs(win), Math.abs(win)];\n  }\n  if (Array.isArray(win)) {\n    const [past, future] = win;\n    if (typeof past === 'number' && typeof future === 'number') {\n      return [Math.abs(past), Math.abs(future)];\n    }\n  }\n  throw new Error('Expecting options.window to be an number or [number, number].');\n}\nfunction totpOptionsValidator(options) {\n  hotpOptionsValidator(options);\n  parseWindowBounds(options.window);\n  if (typeof options.epoch !== 'number') {\n    throw new Error('Expecting options.epoch to be a number.');\n  }\n  if (typeof options.step !== 'number') {\n    throw new Error('Expecting options.step to be a number.');\n  }\n}\nconst totpPadSecret = (secret, encoding, minLength) => {\n  const currentLength = secret.length;\n  const hexSecret = Buffer.from(secret, encoding).toString('hex');\n  if (currentLength < minLength) {\n    const newSecret = new Array(minLength - currentLength + 1).join(hexSecret);\n    return Buffer.from(newSecret, 'hex').slice(0, minLength).toString('hex');\n  }\n  return hexSecret;\n};\nconst totpCreateHmacKey = (algorithm, secret, encoding) => {\n  switch (algorithm) {\n    case exports.HashAlgorithms.SHA1:\n      return totpPadSecret(secret, encoding, 20);\n    case exports.HashAlgorithms.SHA256:\n      return totpPadSecret(secret, encoding, 32);\n    case exports.HashAlgorithms.SHA512:\n      return totpPadSecret(secret, encoding, 64);\n    default:\n      throw new Error(`Expecting algorithm to be one of ${HASH_ALGORITHMS.join(', ')}. Received ${algorithm}.`);\n  }\n};\nfunction totpDefaultOptions() {\n  const options = {\n    algorithm: exports.HashAlgorithms.SHA1,\n    createDigest: createDigestPlaceholder,\n    createHmacKey: totpCreateHmacKey,\n    digits: 6,\n    encoding: exports.KeyEncodings.ASCII,\n    epoch: Date.now(),\n    step: 30,\n    window: 0\n  };\n  return options;\n}\nfunction totpOptions(opt) {\n  const options = { ...totpDefaultOptions(),\n    ...opt\n  };\n  totpOptionsValidator(options);\n  return Object.freeze(options);\n}\nfunction totpCounter(epoch, step) {\n  return Math.floor(epoch / step / 1000);\n}\nfunction totpToken(secret, options) {\n  const counter = totpCounter(options.epoch, options.step);\n  return hotpToken(secret, counter, options);\n}\nfunction totpEpochsInWindow(epoch, direction, deltaPerEpoch, numOfEpoches) {\n  const result = [];\n  if (numOfEpoches === 0) {\n    return result;\n  }\n  for (let i = 1; i <= numOfEpoches; i++) {\n    const delta = direction * i * deltaPerEpoch;\n    result.push(epoch + delta);\n  }\n  return result;\n}\nfunction totpEpochAvailable(epoch, step, win) {\n  const bounds = parseWindowBounds(win);\n  const delta = step * 1000;\n  return {\n    current: epoch,\n    past: totpEpochsInWindow(epoch, -1, delta, bounds[0]),\n    future: totpEpochsInWindow(epoch, 1, delta, bounds[1])\n  };\n}\nfunction totpCheck(token, secret, options) {\n  if (!isTokenValid(token)) {\n    return false;\n  }\n  const systemToken = totpToken(secret, options);\n  return token === systemToken;\n}\nfunction totpCheckByEpoch(epochs, token, secret, options) {\n  let position = null;\n  epochs.some((epoch, idx) => {\n    if (totpCheck(token, secret, { ...options,\n      epoch\n    })) {\n      position = idx + 1;\n      return true;\n    }\n    return false;\n  });\n  return position;\n}\nfunction totpCheckWithWindow(token, secret, options) {\n  if (totpCheck(token, secret, options)) {\n    return 0;\n  }\n  const epochs = totpEpochAvailable(options.epoch, options.step, options.window);\n  const backward = totpCheckByEpoch(epochs.past, token, secret, options);\n  if (backward !== null) {\n    return backward * -1;\n  }\n  return totpCheckByEpoch(epochs.future, token, secret, options);\n}\nfunction totpTimeUsed(epoch, step) {\n  return Math.floor(epoch / 1000) % step;\n}\nfunction totpTimeRemaining(epoch, step) {\n  return step - totpTimeUsed(epoch, step);\n}\nfunction totpKeyuri(accountName, issuer, secret, options) {\n  return keyuri({\n    algorithm: options.algorithm,\n    digits: options.digits,\n    step: options.step,\n    type: exports.Strategy.TOTP,\n    accountName,\n    issuer,\n    secret\n  });\n}\nclass TOTP extends HOTP {\n  create(defaultOptions = {}) {\n    return new TOTP(defaultOptions);\n  }\n  allOptions() {\n    return totpOptions(this.options);\n  }\n  generate(secret) {\n    return totpToken(secret, this.allOptions());\n  }\n  checkDelta(token, secret) {\n    return totpCheckWithWindow(token, secret, this.allOptions());\n  }\n  check(token, secret) {\n    const delta = this.checkDelta(token, secret);\n    return typeof delta === 'number';\n  }\n  verify(opts) {\n    if (typeof opts !== 'object') {\n      throw new Error('Expecting argument 0 of verify to be an object');\n    }\n    return this.check(opts.token, opts.secret);\n  }\n  timeRemaining() {\n    const options = this.allOptions();\n    return totpTimeRemaining(options.epoch, options.step);\n  }\n  timeUsed() {\n    const options = this.allOptions();\n    return totpTimeUsed(options.epoch, options.step);\n  }\n  keyuri(accountName, issuer, secret) {\n    return totpKeyuri(accountName, issuer, secret, this.allOptions());\n  }\n}\n\nfunction authenticatorOptionValidator(options) {\n  totpOptionsValidator(options);\n  if (typeof options.keyDecoder !== 'function') {\n    throw new Error('Expecting options.keyDecoder to be a function.');\n  }\n  if (options.keyEncoder && typeof options.keyEncoder !== 'function') {\n    throw new Error('Expecting options.keyEncoder to be a function.');\n  }\n}\nfunction authenticatorDefaultOptions() {\n  const options = {\n    algorithm: exports.HashAlgorithms.SHA1,\n    createDigest: createDigestPlaceholder,\n    createHmacKey: totpCreateHmacKey,\n    digits: 6,\n    encoding: exports.KeyEncodings.HEX,\n    epoch: Date.now(),\n    step: 30,\n    window: 0\n  };\n  return options;\n}\nfunction authenticatorOptions(opt) {\n  const options = { ...authenticatorDefaultOptions(),\n    ...opt\n  };\n  authenticatorOptionValidator(options);\n  return Object.freeze(options);\n}\nfunction authenticatorEncoder(secret, options) {\n  return options.keyEncoder(secret, options.encoding);\n}\nfunction authenticatorDecoder(secret, options) {\n  return options.keyDecoder(secret, options.encoding);\n}\nfunction authenticatorGenerateSecret(numberOfBytes, options) {\n  const key = options.createRandomBytes(numberOfBytes, options.encoding);\n  return authenticatorEncoder(key, options);\n}\nfunction authenticatorToken(secret, options) {\n  return totpToken(authenticatorDecoder(secret, options), options);\n}\nfunction authenticatorCheckWithWindow(token, secret, options) {\n  return totpCheckWithWindow(token, authenticatorDecoder(secret, options), options);\n}\nclass Authenticator extends TOTP {\n  create(defaultOptions = {}) {\n    return new Authenticator(defaultOptions);\n  }\n  allOptions() {\n    return authenticatorOptions(this.options);\n  }\n  generate(secret) {\n    return authenticatorToken(secret, this.allOptions());\n  }\n  checkDelta(token, secret) {\n    return authenticatorCheckWithWindow(token, secret, this.allOptions());\n  }\n  encode(secret) {\n    return authenticatorEncoder(secret, this.allOptions());\n  }\n  decode(secret) {\n    return authenticatorDecoder(secret, this.allOptions());\n  }\n  generateSecret(numberOfBytes = 10) {\n    return authenticatorGenerateSecret(numberOfBytes, this.allOptions());\n  }\n}\n\nexports.Authenticator = Authenticator;\nexports.HASH_ALGORITHMS = HASH_ALGORITHMS;\nexports.HOTP = HOTP;\nexports.KEY_ENCODINGS = KEY_ENCODINGS;\nexports.OTP = OTP;\nexports.STRATEGY = STRATEGY;\nexports.TOTP = TOTP;\nexports.authenticatorCheckWithWindow = authenticatorCheckWithWindow;\nexports.authenticatorDecoder = authenticatorDecoder;\nexports.authenticatorDefaultOptions = authenticatorDefaultOptions;\nexports.authenticatorEncoder = authenticatorEncoder;\nexports.authenticatorGenerateSecret = authenticatorGenerateSecret;\nexports.authenticatorOptionValidator = authenticatorOptionValidator;\nexports.authenticatorOptions = authenticatorOptions;\nexports.authenticatorToken = authenticatorToken;\nexports.createDigestPlaceholder = createDigestPlaceholder;\nexports.hotpCheck = hotpCheck;\nexports.hotpCounter = hotpCounter;\nexports.hotpCreateHmacKey = hotpCreateHmacKey;\nexports.hotpDefaultOptions = hotpDefaultOptions;\nexports.hotpDigestToToken = hotpDigestToToken;\nexports.hotpKeyuri = hotpKeyuri;\nexports.hotpOptions = hotpOptions;\nexports.hotpOptionsValidator = hotpOptionsValidator;\nexports.hotpToken = hotpToken;\nexports.isTokenValid = isTokenValid;\nexports.keyuri = keyuri;\nexports.objectValues = objectValues;\nexports.padStart = padStart;\nexports.totpCheck = totpCheck;\nexports.totpCheckByEpoch = totpCheckByEpoch;\nexports.totpCheckWithWindow = totpCheckWithWindow;\nexports.totpCounter = totpCounter;\nexports.totpCreateHmacKey = totpCreateHmacKey;\nexports.totpDefaultOptions = totpDefaultOptions;\nexports.totpEpochAvailable = totpEpochAvailable;\nexports.totpKeyuri = totpKeyuri;\nexports.totpOptions = totpOptions;\nexports.totpOptionsValidator = totpOptionsValidator;\nexports.totpPadSecret = totpPadSecret;\nexports.totpTimeRemaining = totpTimeRemaining;\nexports.totpTimeUsed = totpTimeUsed;\nexports.totpToken = totpToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG90cGxpYitjb3JlQDEyLjAuMS9ub2RlX21vZHVsZXMvQG90cGxpYi9jb3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCLHNCQUFzQixLQUFLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkIsb0JBQW9CLEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QixnQkFBZ0IsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVEsRUFBRSxNQUFNO0FBQzVCO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYSxFQUFFLFlBQVksRUFBRSxZQUFZLFNBQVMsUUFBUSxNQUFNO0FBQzVGO0FBQ0E7QUFDQSwyREFBMkQsb0JBQW9CLGFBQWEsYUFBYTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQSw4QkFBOEIsZ0NBQWdDO0FBQzlEO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0Esd0JBQXdCLFlBQVksd0VBQXdFLFlBQVksc0RBQXNELE9BQU8sNkJBQTZCLE1BQU07QUFDeE47QUFDQTtBQUNBLGlDQUFpQztBQUNqQywyQ0FBMkM7QUFDM0MsS0FBSztBQUNMLG9DQUFvQztBQUNwQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDJCQUEyQixhQUFhLGtCQUFrQjtBQUMxSDtBQUNBO0FBQ0EsK0RBQStELHlCQUF5QixhQUFhLGlCQUFpQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJCQUEyQixhQUFhLFVBQVU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIsWUFBWTtBQUNaLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1gsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixvQ0FBb0M7QUFDcEMsNEJBQTRCO0FBQzVCLG1DQUFtQztBQUNuQyw0QkFBNEI7QUFDNUIsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQyw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLCtCQUErQjtBQUMvQixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsY0FBYztBQUNkLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0IsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsNEJBQTRCO0FBQzVCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLGlCQUFpQiIsInNvdXJjZXMiOlsiRDpcXFByb2plY3RcXG5leHQyZmFcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBvdHBsaWIrY29yZUAxMi4wLjFcXG5vZGVfbW9kdWxlc1xcQG90cGxpYlxcY29yZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAb3RwbGliL2NvcmVcbiAqXG4gKiBAYXV0aG9yIEdlcmFsZCBZZW8gPGNvbnRhY3RAZnVzZWR0aG91Z2h0LmNvbT5cbiAqIEB2ZXJzaW9uOiAxMi4wLjFcbiAqIEBsaWNlbnNlOiBNSVRcbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gb2JqZWN0VmFsdWVzKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKGtleSA9PiB2YWx1ZVtrZXldKTtcbn1cbihmdW5jdGlvbiAoSGFzaEFsZ29yaXRobXMpIHtcbiAgSGFzaEFsZ29yaXRobXNbXCJTSEExXCJdID0gXCJzaGExXCI7XG4gIEhhc2hBbGdvcml0aG1zW1wiU0hBMjU2XCJdID0gXCJzaGEyNTZcIjtcbiAgSGFzaEFsZ29yaXRobXNbXCJTSEE1MTJcIl0gPSBcInNoYTUxMlwiO1xufSkoZXhwb3J0cy5IYXNoQWxnb3JpdGhtcyB8fCAoZXhwb3J0cy5IYXNoQWxnb3JpdGhtcyA9IHt9KSk7XG5jb25zdCBIQVNIX0FMR09SSVRITVMgPSBvYmplY3RWYWx1ZXMoZXhwb3J0cy5IYXNoQWxnb3JpdGhtcyk7XG4oZnVuY3Rpb24gKEtleUVuY29kaW5ncykge1xuICBLZXlFbmNvZGluZ3NbXCJBU0NJSVwiXSA9IFwiYXNjaWlcIjtcbiAgS2V5RW5jb2RpbmdzW1wiQkFTRTY0XCJdID0gXCJiYXNlNjRcIjtcbiAgS2V5RW5jb2RpbmdzW1wiSEVYXCJdID0gXCJoZXhcIjtcbiAgS2V5RW5jb2RpbmdzW1wiTEFUSU4xXCJdID0gXCJsYXRpbjFcIjtcbiAgS2V5RW5jb2RpbmdzW1wiVVRGOFwiXSA9IFwidXRmOFwiO1xufSkoZXhwb3J0cy5LZXlFbmNvZGluZ3MgfHwgKGV4cG9ydHMuS2V5RW5jb2RpbmdzID0ge30pKTtcbmNvbnN0IEtFWV9FTkNPRElOR1MgPSBvYmplY3RWYWx1ZXMoZXhwb3J0cy5LZXlFbmNvZGluZ3MpO1xuKGZ1bmN0aW9uIChTdHJhdGVneSkge1xuICBTdHJhdGVneVtcIkhPVFBcIl0gPSBcImhvdHBcIjtcbiAgU3RyYXRlZ3lbXCJUT1RQXCJdID0gXCJ0b3RwXCI7XG59KShleHBvcnRzLlN0cmF0ZWd5IHx8IChleHBvcnRzLlN0cmF0ZWd5ID0ge30pKTtcbmNvbnN0IFNUUkFURUdZID0gb2JqZWN0VmFsdWVzKGV4cG9ydHMuU3RyYXRlZ3kpO1xuY29uc3QgY3JlYXRlRGlnZXN0UGxhY2Vob2xkZXIgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYW4gb3B0aW9ucy5jcmVhdGVEaWdlc3QgaW1wbGVtZW50YXRpb24uJyk7XG59O1xuZnVuY3Rpb24gaXNUb2tlblZhbGlkKHZhbHVlKSB7XG4gIHJldHVybiAvXihcXGQrKSQvLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gcGFkU3RhcnQodmFsdWUsIG1heExlbmd0aCwgZmlsbFN0cmluZykge1xuICBpZiAodmFsdWUubGVuZ3RoID49IG1heExlbmd0aCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25zdCBwYWRkaW5nID0gQXJyYXkobWF4TGVuZ3RoICsgMSkuam9pbihmaWxsU3RyaW5nKTtcbiAgcmV0dXJuIGAke3BhZGRpbmd9JHt2YWx1ZX1gLnNsaWNlKC0xICogbWF4TGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGtleXVyaShvcHRpb25zKSB7XG4gIGNvbnN0IHRtcGwgPSBgb3RwYXV0aDovLyR7b3B0aW9ucy50eXBlfS97bGFiZWxQcmVmaXh9OnthY2NvdW50TmFtZX0/c2VjcmV0PXtzZWNyZXR9e3F1ZXJ5fWA7XG4gIGNvbnN0IHBhcmFtcyA9IFtdO1xuICBpZiAoU1RSQVRFR1kuaW5kZXhPZihvcHRpb25zLnR5cGUpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0aW5nIG9wdGlvbnMudHlwZSB0byBiZSBvbmUgb2YgJHtTVFJBVEVHWS5qb2luKCcsICcpfS4gUmVjZWl2ZWQgJHtvcHRpb25zLnR5cGV9LmApO1xuICB9XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdob3RwJykge1xuICAgIGlmIChvcHRpb25zLmNvdW50ZXIgPT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9ucy5jb3VudGVyICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5jb3VudGVyIHRvIGJlIGEgbnVtYmVyIHdoZW4gb3B0aW9ucy50eXBlIGlzIFwiaG90cFwiLicpO1xuICAgIH1cbiAgICBwYXJhbXMucHVzaChgJmNvdW50ZXI9JHtvcHRpb25zLmNvdW50ZXJ9YCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3RvdHAnICYmIG9wdGlvbnMuc3RlcCkge1xuICAgIHBhcmFtcy5wdXNoKGAmcGVyaW9kPSR7b3B0aW9ucy5zdGVwfWApO1xuICB9XG4gIGlmIChvcHRpb25zLmRpZ2l0cykge1xuICAgIHBhcmFtcy5wdXNoKGAmZGlnaXRzPSR7b3B0aW9ucy5kaWdpdHN9YCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgcGFyYW1zLnB1c2goYCZhbGdvcml0aG09JHtvcHRpb25zLmFsZ29yaXRobS50b1VwcGVyQ2FzZSgpfWApO1xuICB9XG4gIGlmIChvcHRpb25zLmlzc3Vlcikge1xuICAgIHBhcmFtcy5wdXNoKGAmaXNzdWVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuaXNzdWVyKX1gKTtcbiAgfVxuICByZXR1cm4gdG1wbC5yZXBsYWNlKCd7bGFiZWxQcmVmaXh9JywgZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuaXNzdWVyIHx8IG9wdGlvbnMuYWNjb3VudE5hbWUpKS5yZXBsYWNlKCd7YWNjb3VudE5hbWV9JywgZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuYWNjb3VudE5hbWUpKS5yZXBsYWNlKCd7c2VjcmV0fScsIG9wdGlvbnMuc2VjcmV0KS5yZXBsYWNlKCd7cXVlcnl9JywgcGFyYW1zLmpvaW4oJycpKTtcbn1cbmNsYXNzIE9UUCB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9kZWZhdWx0T3B0aW9ucyA9IE9iamVjdC5mcmVlemUoeyAuLi5kZWZhdWx0T3B0aW9uc1xuICAgIH0pO1xuICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgfVxuICBjcmVhdGUoZGVmYXVsdE9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgT1RQKGRlZmF1bHRPcHRpb25zKTtcbiAgfVxuICBjbG9uZShkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmNyZWF0ZSh7IC4uLnRoaXMuX2RlZmF1bHRPcHRpb25zLFxuICAgICAgLi4uZGVmYXVsdE9wdGlvbnNcbiAgICB9KTtcbiAgICBpbnN0YW5jZS5vcHRpb25zID0gdGhpcy5fb3B0aW9ucztcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi50aGlzLl9kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuX29wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5mcmVlemUoeyAuLi50aGlzLl9vcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIGFsbE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgfVxuICByZXNldE9wdGlvbnMoKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe30pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhvdHBPcHRpb25zVmFsaWRhdG9yKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmNyZWF0ZURpZ2VzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIG9wdGlvbnMuY3JlYXRlRGlnZXN0IHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmNyZWF0ZUhtYWNLZXkgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyBvcHRpb25zLmNyZWF0ZUhtYWNLZXkgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuZGlnaXRzICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIG9wdGlvbnMuZGlnaXRzIHRvIGJlIGEgbnVtYmVyLicpO1xuICB9XG4gIGlmICghb3B0aW9ucy5hbGdvcml0aG0gfHwgSEFTSF9BTEdPUklUSE1TLmluZGV4T2Yob3B0aW9ucy5hbGdvcml0aG0pIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0aW5nIG9wdGlvbnMuYWxnb3JpdGhtIHRvIGJlIG9uZSBvZiAke0hBU0hfQUxHT1JJVEhNUy5qb2luKCcsICcpfS4gUmVjZWl2ZWQgJHtvcHRpb25zLmFsZ29yaXRobX0uYCk7XG4gIH1cbiAgaWYgKCFvcHRpb25zLmVuY29kaW5nIHx8IEtFWV9FTkNPRElOR1MuaW5kZXhPZihvcHRpb25zLmVuY29kaW5nKSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGluZyBvcHRpb25zLmVuY29kaW5nIHRvIGJlIG9uZSBvZiAke0tFWV9FTkNPRElOR1Muam9pbignLCAnKX0uIFJlY2VpdmVkICR7b3B0aW9ucy5lbmNvZGluZ30uYCk7XG4gIH1cbn1cbmNvbnN0IGhvdHBDcmVhdGVIbWFjS2V5ID0gKGFsZ29yaXRobSwgc2VjcmV0LCBlbmNvZGluZykgPT4ge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcmV0LCBlbmNvZGluZykudG9TdHJpbmcoJ2hleCcpO1xufTtcbmZ1bmN0aW9uIGhvdHBEZWZhdWx0T3B0aW9ucygpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBhbGdvcml0aG06IGV4cG9ydHMuSGFzaEFsZ29yaXRobXMuU0hBMSxcbiAgICBjcmVhdGVIbWFjS2V5OiBob3RwQ3JlYXRlSG1hY0tleSxcbiAgICBjcmVhdGVEaWdlc3Q6IGNyZWF0ZURpZ2VzdFBsYWNlaG9sZGVyLFxuICAgIGRpZ2l0czogNixcbiAgICBlbmNvZGluZzogZXhwb3J0cy5LZXlFbmNvZGluZ3MuQVNDSUlcbiAgfTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBob3RwT3B0aW9ucyhvcHQpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHsgLi4uaG90cERlZmF1bHRPcHRpb25zKCksXG4gICAgLi4ub3B0XG4gIH07XG4gIGhvdHBPcHRpb25zVmFsaWRhdG9yKG9wdGlvbnMpO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGhvdHBDb3VudGVyKGNvdW50ZXIpIHtcbiAgY29uc3QgaGV4Q291bnRlciA9IGNvdW50ZXIudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gcGFkU3RhcnQoaGV4Q291bnRlciwgMTYsICcwJyk7XG59XG5mdW5jdGlvbiBob3RwRGlnZXN0VG9Ub2tlbihoZXhEaWdlc3QsIGRpZ2l0cykge1xuICBjb25zdCBkaWdlc3QgPSBCdWZmZXIuZnJvbShoZXhEaWdlc3QsICdoZXgnKTtcbiAgY29uc3Qgb2Zmc2V0ID0gZGlnZXN0W2RpZ2VzdC5sZW5ndGggLSAxXSAmIDB4ZjtcbiAgY29uc3QgYmluYXJ5ID0gKGRpZ2VzdFtvZmZzZXRdICYgMHg3ZikgPDwgMjQgfCAoZGlnZXN0W29mZnNldCArIDFdICYgMHhmZikgPDwgMTYgfCAoZGlnZXN0W29mZnNldCArIDJdICYgMHhmZikgPDwgOCB8IGRpZ2VzdFtvZmZzZXQgKyAzXSAmIDB4ZmY7XG4gIGNvbnN0IHRva2VuID0gYmluYXJ5ICUgTWF0aC5wb3coMTAsIGRpZ2l0cyk7XG4gIHJldHVybiBwYWRTdGFydChTdHJpbmcodG9rZW4pLCBkaWdpdHMsICcwJyk7XG59XG5mdW5jdGlvbiBob3RwRGlnZXN0KHNlY3JldCwgY291bnRlciwgb3B0aW9ucykge1xuICBjb25zdCBoZXhDb3VudGVyID0gaG90cENvdW50ZXIoY291bnRlcik7XG4gIGNvbnN0IGhtYWNLZXkgPSBvcHRpb25zLmNyZWF0ZUhtYWNLZXkob3B0aW9ucy5hbGdvcml0aG0sIHNlY3JldCwgb3B0aW9ucy5lbmNvZGluZyk7XG4gIHJldHVybiBvcHRpb25zLmNyZWF0ZURpZ2VzdChvcHRpb25zLmFsZ29yaXRobSwgaG1hY0tleSwgaGV4Q291bnRlcik7XG59XG5mdW5jdGlvbiBob3RwVG9rZW4oc2VjcmV0LCBjb3VudGVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGhleERpZ2VzdCA9IG9wdGlvbnMuZGlnZXN0IHx8IGhvdHBEaWdlc3Qoc2VjcmV0LCBjb3VudGVyLCBvcHRpb25zKTtcbiAgcmV0dXJuIGhvdHBEaWdlc3RUb1Rva2VuKGhleERpZ2VzdCwgb3B0aW9ucy5kaWdpdHMpO1xufVxuZnVuY3Rpb24gaG90cENoZWNrKHRva2VuLCBzZWNyZXQsIGNvdW50ZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1Rva2VuVmFsaWQodG9rZW4pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHN5c3RlbVRva2VuID0gaG90cFRva2VuKHNlY3JldCwgY291bnRlciwgb3B0aW9ucyk7XG4gIHJldHVybiB0b2tlbiA9PT0gc3lzdGVtVG9rZW47XG59XG5mdW5jdGlvbiBob3RwS2V5dXJpKGFjY291bnROYW1lLCBpc3N1ZXIsIHNlY3JldCwgY291bnRlciwgb3B0aW9ucykge1xuICByZXR1cm4ga2V5dXJpKHtcbiAgICBhbGdvcml0aG06IG9wdGlvbnMuYWxnb3JpdGhtLFxuICAgIGRpZ2l0czogb3B0aW9ucy5kaWdpdHMsXG4gICAgdHlwZTogZXhwb3J0cy5TdHJhdGVneS5IT1RQLFxuICAgIGFjY291bnROYW1lLFxuICAgIGNvdW50ZXIsXG4gICAgaXNzdWVyLFxuICAgIHNlY3JldFxuICB9KTtcbn1cbmNsYXNzIEhPVFAgZXh0ZW5kcyBPVFAge1xuICBjcmVhdGUoZGVmYXVsdE9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgSE9UUChkZWZhdWx0T3B0aW9ucyk7XG4gIH1cbiAgYWxsT3B0aW9ucygpIHtcbiAgICByZXR1cm4gaG90cE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgfVxuICBnZW5lcmF0ZShzZWNyZXQsIGNvdW50ZXIpIHtcbiAgICByZXR1cm4gaG90cFRva2VuKHNlY3JldCwgY291bnRlciwgdGhpcy5hbGxPcHRpb25zKCkpO1xuICB9XG4gIGNoZWNrKHRva2VuLCBzZWNyZXQsIGNvdW50ZXIpIHtcbiAgICByZXR1cm4gaG90cENoZWNrKHRva2VuLCBzZWNyZXQsIGNvdW50ZXIsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxuICB2ZXJpZnkob3B0cykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIGFyZ3VtZW50IDAgb2YgdmVyaWZ5IHRvIGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jaGVjayhvcHRzLnRva2VuLCBvcHRzLnNlY3JldCwgb3B0cy5jb3VudGVyKTtcbiAgfVxuICBrZXl1cmkoYWNjb3VudE5hbWUsIGlzc3Vlciwgc2VjcmV0LCBjb3VudGVyKSB7XG4gICAgcmV0dXJuIGhvdHBLZXl1cmkoYWNjb3VudE5hbWUsIGlzc3Vlciwgc2VjcmV0LCBjb3VudGVyLCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VXaW5kb3dCb3VuZHMod2luKSB7XG4gIGlmICh0eXBlb2Ygd2luID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbTWF0aC5hYnMod2luKSwgTWF0aC5hYnMod2luKV07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkod2luKSkge1xuICAgIGNvbnN0IFtwYXN0LCBmdXR1cmVdID0gd2luO1xuICAgIGlmICh0eXBlb2YgcGFzdCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGZ1dHVyZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBbTWF0aC5hYnMocGFzdCksIE1hdGguYWJzKGZ1dHVyZSldO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyBvcHRpb25zLndpbmRvdyB0byBiZSBhbiBudW1iZXIgb3IgW251bWJlciwgbnVtYmVyXS4nKTtcbn1cbmZ1bmN0aW9uIHRvdHBPcHRpb25zVmFsaWRhdG9yKG9wdGlvbnMpIHtcbiAgaG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucyk7XG4gIHBhcnNlV2luZG93Qm91bmRzKG9wdGlvbnMud2luZG93KTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmVwb2NoICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIG9wdGlvbnMuZXBvY2ggdG8gYmUgYSBudW1iZXIuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnN0ZXAgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5zdGVwIHRvIGJlIGEgbnVtYmVyLicpO1xuICB9XG59XG5jb25zdCB0b3RwUGFkU2VjcmV0ID0gKHNlY3JldCwgZW5jb2RpbmcsIG1pbkxlbmd0aCkgPT4ge1xuICBjb25zdCBjdXJyZW50TGVuZ3RoID0gc2VjcmV0Lmxlbmd0aDtcbiAgY29uc3QgaGV4U2VjcmV0ID0gQnVmZmVyLmZyb20oc2VjcmV0LCBlbmNvZGluZykudG9TdHJpbmcoJ2hleCcpO1xuICBpZiAoY3VycmVudExlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgIGNvbnN0IG5ld1NlY3JldCA9IG5ldyBBcnJheShtaW5MZW5ndGggLSBjdXJyZW50TGVuZ3RoICsgMSkuam9pbihoZXhTZWNyZXQpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShuZXdTZWNyZXQsICdoZXgnKS5zbGljZSgwLCBtaW5MZW5ndGgpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuICByZXR1cm4gaGV4U2VjcmV0O1xufTtcbmNvbnN0IHRvdHBDcmVhdGVIbWFjS2V5ID0gKGFsZ29yaXRobSwgc2VjcmV0LCBlbmNvZGluZykgPT4ge1xuICBzd2l0Y2ggKGFsZ29yaXRobSkge1xuICAgIGNhc2UgZXhwb3J0cy5IYXNoQWxnb3JpdGhtcy5TSEExOlxuICAgICAgcmV0dXJuIHRvdHBQYWRTZWNyZXQoc2VjcmV0LCBlbmNvZGluZywgMjApO1xuICAgIGNhc2UgZXhwb3J0cy5IYXNoQWxnb3JpdGhtcy5TSEEyNTY6XG4gICAgICByZXR1cm4gdG90cFBhZFNlY3JldChzZWNyZXQsIGVuY29kaW5nLCAzMik7XG4gICAgY2FzZSBleHBvcnRzLkhhc2hBbGdvcml0aG1zLlNIQTUxMjpcbiAgICAgIHJldHVybiB0b3RwUGFkU2VjcmV0KHNlY3JldCwgZW5jb2RpbmcsIDY0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RpbmcgYWxnb3JpdGhtIHRvIGJlIG9uZSBvZiAke0hBU0hfQUxHT1JJVEhNUy5qb2luKCcsICcpfS4gUmVjZWl2ZWQgJHthbGdvcml0aG19LmApO1xuICB9XG59O1xuZnVuY3Rpb24gdG90cERlZmF1bHRPcHRpb25zKCkge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGFsZ29yaXRobTogZXhwb3J0cy5IYXNoQWxnb3JpdGhtcy5TSEExLFxuICAgIGNyZWF0ZURpZ2VzdDogY3JlYXRlRGlnZXN0UGxhY2Vob2xkZXIsXG4gICAgY3JlYXRlSG1hY0tleTogdG90cENyZWF0ZUhtYWNLZXksXG4gICAgZGlnaXRzOiA2LFxuICAgIGVuY29kaW5nOiBleHBvcnRzLktleUVuY29kaW5ncy5BU0NJSSxcbiAgICBlcG9jaDogRGF0ZS5ub3coKSxcbiAgICBzdGVwOiAzMCxcbiAgICB3aW5kb3c6IDBcbiAgfTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiB0b3RwT3B0aW9ucyhvcHQpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHsgLi4udG90cERlZmF1bHRPcHRpb25zKCksXG4gICAgLi4ub3B0XG4gIH07XG4gIHRvdHBPcHRpb25zVmFsaWRhdG9yKG9wdGlvbnMpO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHRvdHBDb3VudGVyKGVwb2NoLCBzdGVwKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGVwb2NoIC8gc3RlcCAvIDEwMDApO1xufVxuZnVuY3Rpb24gdG90cFRva2VuKHNlY3JldCwgb3B0aW9ucykge1xuICBjb25zdCBjb3VudGVyID0gdG90cENvdW50ZXIob3B0aW9ucy5lcG9jaCwgb3B0aW9ucy5zdGVwKTtcbiAgcmV0dXJuIGhvdHBUb2tlbihzZWNyZXQsIGNvdW50ZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdG90cEVwb2Noc0luV2luZG93KGVwb2NoLCBkaXJlY3Rpb24sIGRlbHRhUGVyRXBvY2gsIG51bU9mRXBvY2hlcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKG51bU9mRXBvY2hlcyA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtT2ZFcG9jaGVzOyBpKyspIHtcbiAgICBjb25zdCBkZWx0YSA9IGRpcmVjdGlvbiAqIGkgKiBkZWx0YVBlckVwb2NoO1xuICAgIHJlc3VsdC5wdXNoKGVwb2NoICsgZGVsdGEpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b3RwRXBvY2hBdmFpbGFibGUoZXBvY2gsIHN0ZXAsIHdpbikge1xuICBjb25zdCBib3VuZHMgPSBwYXJzZVdpbmRvd0JvdW5kcyh3aW4pO1xuICBjb25zdCBkZWx0YSA9IHN0ZXAgKiAxMDAwO1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGVwb2NoLFxuICAgIHBhc3Q6IHRvdHBFcG9jaHNJbldpbmRvdyhlcG9jaCwgLTEsIGRlbHRhLCBib3VuZHNbMF0pLFxuICAgIGZ1dHVyZTogdG90cEVwb2Noc0luV2luZG93KGVwb2NoLCAxLCBkZWx0YSwgYm91bmRzWzFdKVxuICB9O1xufVxuZnVuY3Rpb24gdG90cENoZWNrKHRva2VuLCBzZWNyZXQsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1Rva2VuVmFsaWQodG9rZW4pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHN5c3RlbVRva2VuID0gdG90cFRva2VuKHNlY3JldCwgb3B0aW9ucyk7XG4gIHJldHVybiB0b2tlbiA9PT0gc3lzdGVtVG9rZW47XG59XG5mdW5jdGlvbiB0b3RwQ2hlY2tCeUVwb2NoKGVwb2NocywgdG9rZW4sIHNlY3JldCwgb3B0aW9ucykge1xuICBsZXQgcG9zaXRpb24gPSBudWxsO1xuICBlcG9jaHMuc29tZSgoZXBvY2gsIGlkeCkgPT4ge1xuICAgIGlmICh0b3RwQ2hlY2sodG9rZW4sIHNlY3JldCwgeyAuLi5vcHRpb25zLFxuICAgICAgZXBvY2hcbiAgICB9KSkge1xuICAgICAgcG9zaXRpb24gPSBpZHggKyAxO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiBwb3NpdGlvbjtcbn1cbmZ1bmN0aW9uIHRvdHBDaGVja1dpdGhXaW5kb3codG9rZW4sIHNlY3JldCwgb3B0aW9ucykge1xuICBpZiAodG90cENoZWNrKHRva2VuLCBzZWNyZXQsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgZXBvY2hzID0gdG90cEVwb2NoQXZhaWxhYmxlKG9wdGlvbnMuZXBvY2gsIG9wdGlvbnMuc3RlcCwgb3B0aW9ucy53aW5kb3cpO1xuICBjb25zdCBiYWNrd2FyZCA9IHRvdHBDaGVja0J5RXBvY2goZXBvY2hzLnBhc3QsIHRva2VuLCBzZWNyZXQsIG9wdGlvbnMpO1xuICBpZiAoYmFja3dhcmQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gYmFja3dhcmQgKiAtMTtcbiAgfVxuICByZXR1cm4gdG90cENoZWNrQnlFcG9jaChlcG9jaHMuZnV0dXJlLCB0b2tlbiwgc2VjcmV0LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHRvdHBUaW1lVXNlZChlcG9jaCwgc3RlcCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihlcG9jaCAvIDEwMDApICUgc3RlcDtcbn1cbmZ1bmN0aW9uIHRvdHBUaW1lUmVtYWluaW5nKGVwb2NoLCBzdGVwKSB7XG4gIHJldHVybiBzdGVwIC0gdG90cFRpbWVVc2VkKGVwb2NoLCBzdGVwKTtcbn1cbmZ1bmN0aW9uIHRvdHBLZXl1cmkoYWNjb3VudE5hbWUsIGlzc3Vlciwgc2VjcmV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBrZXl1cmkoe1xuICAgIGFsZ29yaXRobTogb3B0aW9ucy5hbGdvcml0aG0sXG4gICAgZGlnaXRzOiBvcHRpb25zLmRpZ2l0cyxcbiAgICBzdGVwOiBvcHRpb25zLnN0ZXAsXG4gICAgdHlwZTogZXhwb3J0cy5TdHJhdGVneS5UT1RQLFxuICAgIGFjY291bnROYW1lLFxuICAgIGlzc3VlcixcbiAgICBzZWNyZXRcbiAgfSk7XG59XG5jbGFzcyBUT1RQIGV4dGVuZHMgSE9UUCB7XG4gIGNyZWF0ZShkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBUT1RQKGRlZmF1bHRPcHRpb25zKTtcbiAgfVxuICBhbGxPcHRpb25zKCkge1xuICAgIHJldHVybiB0b3RwT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICB9XG4gIGdlbmVyYXRlKHNlY3JldCkge1xuICAgIHJldHVybiB0b3RwVG9rZW4oc2VjcmV0LCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbiAgY2hlY2tEZWx0YSh0b2tlbiwgc2VjcmV0KSB7XG4gICAgcmV0dXJuIHRvdHBDaGVja1dpdGhXaW5kb3codG9rZW4sIHNlY3JldCwgdGhpcy5hbGxPcHRpb25zKCkpO1xuICB9XG4gIGNoZWNrKHRva2VuLCBzZWNyZXQpIHtcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuY2hlY2tEZWx0YSh0b2tlbiwgc2VjcmV0KTtcbiAgICByZXR1cm4gdHlwZW9mIGRlbHRhID09PSAnbnVtYmVyJztcbiAgfVxuICB2ZXJpZnkob3B0cykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIGFyZ3VtZW50IDAgb2YgdmVyaWZ5IHRvIGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jaGVjayhvcHRzLnRva2VuLCBvcHRzLnNlY3JldCk7XG4gIH1cbiAgdGltZVJlbWFpbmluZygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5hbGxPcHRpb25zKCk7XG4gICAgcmV0dXJuIHRvdHBUaW1lUmVtYWluaW5nKG9wdGlvbnMuZXBvY2gsIG9wdGlvbnMuc3RlcCk7XG4gIH1cbiAgdGltZVVzZWQoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuYWxsT3B0aW9ucygpO1xuICAgIHJldHVybiB0b3RwVGltZVVzZWQob3B0aW9ucy5lcG9jaCwgb3B0aW9ucy5zdGVwKTtcbiAgfVxuICBrZXl1cmkoYWNjb3VudE5hbWUsIGlzc3Vlciwgc2VjcmV0KSB7XG4gICAgcmV0dXJuIHRvdHBLZXl1cmkoYWNjb3VudE5hbWUsIGlzc3Vlciwgc2VjcmV0LCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXV0aGVudGljYXRvck9wdGlvblZhbGlkYXRvcihvcHRpb25zKSB7XG4gIHRvdHBPcHRpb25zVmFsaWRhdG9yKG9wdGlvbnMpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMua2V5RGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIG9wdGlvbnMua2V5RGVjb2RlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG4gIGlmIChvcHRpb25zLmtleUVuY29kZXIgJiYgdHlwZW9mIG9wdGlvbnMua2V5RW5jb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIG9wdGlvbnMua2V5RW5jb2RlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG59XG5mdW5jdGlvbiBhdXRoZW50aWNhdG9yRGVmYXVsdE9wdGlvbnMoKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgYWxnb3JpdGhtOiBleHBvcnRzLkhhc2hBbGdvcml0aG1zLlNIQTEsXG4gICAgY3JlYXRlRGlnZXN0OiBjcmVhdGVEaWdlc3RQbGFjZWhvbGRlcixcbiAgICBjcmVhdGVIbWFjS2V5OiB0b3RwQ3JlYXRlSG1hY0tleSxcbiAgICBkaWdpdHM6IDYsXG4gICAgZW5jb2Rpbmc6IGV4cG9ydHMuS2V5RW5jb2RpbmdzLkhFWCxcbiAgICBlcG9jaDogRGF0ZS5ub3coKSxcbiAgICBzdGVwOiAzMCxcbiAgICB3aW5kb3c6IDBcbiAgfTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBhdXRoZW50aWNhdG9yT3B0aW9ucyhvcHQpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHsgLi4uYXV0aGVudGljYXRvckRlZmF1bHRPcHRpb25zKCksXG4gICAgLi4ub3B0XG4gIH07XG4gIGF1dGhlbnRpY2F0b3JPcHRpb25WYWxpZGF0b3Iob3B0aW9ucyk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYXV0aGVudGljYXRvckVuY29kZXIoc2VjcmV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmtleUVuY29kZXIoc2VjcmV0LCBvcHRpb25zLmVuY29kaW5nKTtcbn1cbmZ1bmN0aW9uIGF1dGhlbnRpY2F0b3JEZWNvZGVyKHNlY3JldCwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5rZXlEZWNvZGVyKHNlY3JldCwgb3B0aW9ucy5lbmNvZGluZyk7XG59XG5mdW5jdGlvbiBhdXRoZW50aWNhdG9yR2VuZXJhdGVTZWNyZXQobnVtYmVyT2ZCeXRlcywgb3B0aW9ucykge1xuICBjb25zdCBrZXkgPSBvcHRpb25zLmNyZWF0ZVJhbmRvbUJ5dGVzKG51bWJlck9mQnl0ZXMsIG9wdGlvbnMuZW5jb2RpbmcpO1xuICByZXR1cm4gYXV0aGVudGljYXRvckVuY29kZXIoa2V5LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGF1dGhlbnRpY2F0b3JUb2tlbihzZWNyZXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvdHBUb2tlbihhdXRoZW50aWNhdG9yRGVjb2RlcihzZWNyZXQsIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGF1dGhlbnRpY2F0b3JDaGVja1dpdGhXaW5kb3codG9rZW4sIHNlY3JldCwgb3B0aW9ucykge1xuICByZXR1cm4gdG90cENoZWNrV2l0aFdpbmRvdyh0b2tlbiwgYXV0aGVudGljYXRvckRlY29kZXIoc2VjcmV0LCBvcHRpb25zKSwgb3B0aW9ucyk7XG59XG5jbGFzcyBBdXRoZW50aWNhdG9yIGV4dGVuZHMgVE9UUCB7XG4gIGNyZWF0ZShkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdG9yKGRlZmF1bHRPcHRpb25zKTtcbiAgfVxuICBhbGxPcHRpb25zKCkge1xuICAgIHJldHVybiBhdXRoZW50aWNhdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICB9XG4gIGdlbmVyYXRlKHNlY3JldCkge1xuICAgIHJldHVybiBhdXRoZW50aWNhdG9yVG9rZW4oc2VjcmV0LCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbiAgY2hlY2tEZWx0YSh0b2tlbiwgc2VjcmV0KSB7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0b3JDaGVja1dpdGhXaW5kb3codG9rZW4sIHNlY3JldCwgdGhpcy5hbGxPcHRpb25zKCkpO1xuICB9XG4gIGVuY29kZShzZWNyZXQpIHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRvckVuY29kZXIoc2VjcmV0LCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbiAgZGVjb2RlKHNlY3JldCkge1xuICAgIHJldHVybiBhdXRoZW50aWNhdG9yRGVjb2RlcihzZWNyZXQsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxuICBnZW5lcmF0ZVNlY3JldChudW1iZXJPZkJ5dGVzID0gMTApIHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRvckdlbmVyYXRlU2VjcmV0KG51bWJlck9mQnl0ZXMsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxufVxuXG5leHBvcnRzLkF1dGhlbnRpY2F0b3IgPSBBdXRoZW50aWNhdG9yO1xuZXhwb3J0cy5IQVNIX0FMR09SSVRITVMgPSBIQVNIX0FMR09SSVRITVM7XG5leHBvcnRzLkhPVFAgPSBIT1RQO1xuZXhwb3J0cy5LRVlfRU5DT0RJTkdTID0gS0VZX0VOQ09ESU5HUztcbmV4cG9ydHMuT1RQID0gT1RQO1xuZXhwb3J0cy5TVFJBVEVHWSA9IFNUUkFURUdZO1xuZXhwb3J0cy5UT1RQID0gVE9UUDtcbmV4cG9ydHMuYXV0aGVudGljYXRvckNoZWNrV2l0aFdpbmRvdyA9IGF1dGhlbnRpY2F0b3JDaGVja1dpdGhXaW5kb3c7XG5leHBvcnRzLmF1dGhlbnRpY2F0b3JEZWNvZGVyID0gYXV0aGVudGljYXRvckRlY29kZXI7XG5leHBvcnRzLmF1dGhlbnRpY2F0b3JEZWZhdWx0T3B0aW9ucyA9IGF1dGhlbnRpY2F0b3JEZWZhdWx0T3B0aW9ucztcbmV4cG9ydHMuYXV0aGVudGljYXRvckVuY29kZXIgPSBhdXRoZW50aWNhdG9yRW5jb2RlcjtcbmV4cG9ydHMuYXV0aGVudGljYXRvckdlbmVyYXRlU2VjcmV0ID0gYXV0aGVudGljYXRvckdlbmVyYXRlU2VjcmV0O1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yT3B0aW9uVmFsaWRhdG9yID0gYXV0aGVudGljYXRvck9wdGlvblZhbGlkYXRvcjtcbmV4cG9ydHMuYXV0aGVudGljYXRvck9wdGlvbnMgPSBhdXRoZW50aWNhdG9yT3B0aW9ucztcbmV4cG9ydHMuYXV0aGVudGljYXRvclRva2VuID0gYXV0aGVudGljYXRvclRva2VuO1xuZXhwb3J0cy5jcmVhdGVEaWdlc3RQbGFjZWhvbGRlciA9IGNyZWF0ZURpZ2VzdFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5ob3RwQ2hlY2sgPSBob3RwQ2hlY2s7XG5leHBvcnRzLmhvdHBDb3VudGVyID0gaG90cENvdW50ZXI7XG5leHBvcnRzLmhvdHBDcmVhdGVIbWFjS2V5ID0gaG90cENyZWF0ZUhtYWNLZXk7XG5leHBvcnRzLmhvdHBEZWZhdWx0T3B0aW9ucyA9IGhvdHBEZWZhdWx0T3B0aW9ucztcbmV4cG9ydHMuaG90cERpZ2VzdFRvVG9rZW4gPSBob3RwRGlnZXN0VG9Ub2tlbjtcbmV4cG9ydHMuaG90cEtleXVyaSA9IGhvdHBLZXl1cmk7XG5leHBvcnRzLmhvdHBPcHRpb25zID0gaG90cE9wdGlvbnM7XG5leHBvcnRzLmhvdHBPcHRpb25zVmFsaWRhdG9yID0gaG90cE9wdGlvbnNWYWxpZGF0b3I7XG5leHBvcnRzLmhvdHBUb2tlbiA9IGhvdHBUb2tlbjtcbmV4cG9ydHMuaXNUb2tlblZhbGlkID0gaXNUb2tlblZhbGlkO1xuZXhwb3J0cy5rZXl1cmkgPSBrZXl1cmk7XG5leHBvcnRzLm9iamVjdFZhbHVlcyA9IG9iamVjdFZhbHVlcztcbmV4cG9ydHMucGFkU3RhcnQgPSBwYWRTdGFydDtcbmV4cG9ydHMudG90cENoZWNrID0gdG90cENoZWNrO1xuZXhwb3J0cy50b3RwQ2hlY2tCeUVwb2NoID0gdG90cENoZWNrQnlFcG9jaDtcbmV4cG9ydHMudG90cENoZWNrV2l0aFdpbmRvdyA9IHRvdHBDaGVja1dpdGhXaW5kb3c7XG5leHBvcnRzLnRvdHBDb3VudGVyID0gdG90cENvdW50ZXI7XG5leHBvcnRzLnRvdHBDcmVhdGVIbWFjS2V5ID0gdG90cENyZWF0ZUhtYWNLZXk7XG5leHBvcnRzLnRvdHBEZWZhdWx0T3B0aW9ucyA9IHRvdHBEZWZhdWx0T3B0aW9ucztcbmV4cG9ydHMudG90cEVwb2NoQXZhaWxhYmxlID0gdG90cEVwb2NoQXZhaWxhYmxlO1xuZXhwb3J0cy50b3RwS2V5dXJpID0gdG90cEtleXVyaTtcbmV4cG9ydHMudG90cE9wdGlvbnMgPSB0b3RwT3B0aW9ucztcbmV4cG9ydHMudG90cE9wdGlvbnNWYWxpZGF0b3IgPSB0b3RwT3B0aW9uc1ZhbGlkYXRvcjtcbmV4cG9ydHMudG90cFBhZFNlY3JldCA9IHRvdHBQYWRTZWNyZXQ7XG5leHBvcnRzLnRvdHBUaW1lUmVtYWluaW5nID0gdG90cFRpbWVSZW1haW5pbmc7XG5leHBvcnRzLnRvdHBUaW1lVXNlZCA9IHRvdHBUaW1lVXNlZDtcbmV4cG9ydHMudG90cFRva2VuID0gdG90cFRva2VuO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@otplib+core@12.0.1/node_modules/@otplib/core/index.js\n");

/***/ })

};
;